================================================================================
RISC-V 64I-Zba PROCESSOR - DESIGN SPECIFICATION
================================================================================

Document Version: 1.0
Project: LFX Mentorship RISC-V Vector Coding Challenge

================================================================================
1. PROJECT OVERVIEW
================================================================================

Objective: Design and implement a RISC-V 64-bit processor core implementing
           RV64I base integer instruction set with Zba (address generation)
           extension.

================================================================================
2. ARCHITECTURE DECISIONS
================================================================================

Pipeline Depth:       5-stage (IF, ID, EX, MEM, WB)
Hazard Handling:      Stall-only (NO forwarding/bypassing)
Branch Strategy:      Static not-taken, flush on taken (2-cycle penalty)
Reset:                Active-low asynchronous reset (rst_n)
Memory Interface:     Synchronous, single-cycle access
Naming Convention:    snake_case
Data Width:           64-bit

================================================================================
3. PIPELINE STAGES
================================================================================

Stage   Name        Responsibilities
------  ----------  ------------------------------------------------------------
IF      Fetch       - PC management (increment, branch target load)
                    - Instruction memory read
                    - Next PC calculation

ID      Decode      - Instruction decoding
                    - Register file read (rs1, rs2)
                    - Immediate value generation
                    - Hazard detection (stall generation)
                    - Control signal generation

EX      Execute     - ALU operations (arithmetic, logic, shifts)
                    - Zba extension operations
                    - Branch condition evaluation
                    - Memory address calculation
                    - Branch target calculation

MEM     Memory      - Data memory read (loads)
                    - Data memory write (stores)
                    - Byte/halfword/word/doubleword alignment

WB      Writeback   - Register file write
                    - Select between ALU result and memory data

================================================================================
4. RV64I BASE INSTRUCTION SET
================================================================================

4.1 R-Type (Register-Register) - opcode: 0110011 (32-bit), 0111011 (64-bit W)
------------------------------------------------------------------------------
Instruction   funct7    funct3   Operation
-----------   -------   ------   -----------------------------------------
ADD           0000000   000      rd = rs1 + rs2
SUB           0100000   000      rd = rs1 - rs2
SLL           0000000   001      rd = rs1 << rs2[5:0]
SLT           0000000   010      rd = (signed)rs1 < (signed)rs2 ? 1 : 0
SLTU          0000000   011      rd = rs1 < rs2 ? 1 : 0
XOR           0000000   100      rd = rs1 ^ rs2
SRL           0000000   101      rd = rs1 >> rs2[5:0] (logical)
SRA           0100000   101      rd = rs1 >>> rs2[5:0] (arithmetic)
OR            0000000   110      rd = rs1 | rs2
AND           0000000   111      rd = rs1 & rs2

ADDW          0000000   000      rd = sext((rs1 + rs2)[31:0])
SUBW          0100000   000      rd = sext((rs1 - rs2)[31:0])
SLLW          0000000   001      rd = sext((rs1[31:0] << rs2[4:0])[31:0])
SRLW          0000000   101      rd = sext((rs1[31:0] >> rs2[4:0])[31:0])
SRAW          0100000   101      rd = sext((rs1[31:0] >>> rs2[4:0])[31:0])

4.2 I-Type (Immediate) - opcode: 0010011 (arith), 0011011 (W), 0000011 (load)
------------------------------------------------------------------------------
Instruction   funct3   Operation
-----------   ------   -----------------------------------------
ADDI          000      rd = rs1 + sext(imm)
SLTI          010      rd = (signed)rs1 < sext(imm) ? 1 : 0
SLTIU         011      rd = rs1 < sext(imm) ? 1 : 0
XORI          100      rd = rs1 ^ sext(imm)
ORI           110      rd = rs1 | sext(imm)
ANDI          111      rd = rs1 & sext(imm)
SLLI          001      rd = rs1 << imm[5:0]
SRLI          101      rd = rs1 >> imm[5:0] (logical)
SRAI          101      rd = rs1 >>> imm[5:0] (arithmetic, imm[10]=1)

ADDIW         000      rd = sext((rs1 + sext(imm))[31:0])
SLLIW         001      rd = sext((rs1[31:0] << imm[4:0])[31:0])
SRLIW         101      rd = sext((rs1[31:0] >> imm[4:0])[31:0])
SRAIW         101      rd = sext((rs1[31:0] >>> imm[4:0])[31:0])

4.3 Load Instructions - opcode: 0000011
------------------------------------------------------------------------------
Instruction   funct3   Operation
-----------   ------   -----------------------------------------
LB            000      rd = sext(mem[rs1+imm][7:0])
LH            001      rd = sext(mem[rs1+imm][15:0])
LW            010      rd = sext(mem[rs1+imm][31:0])
LD            011      rd = mem[rs1+imm][63:0]
LBU           100      rd = zext(mem[rs1+imm][7:0])
LHU           101      rd = zext(mem[rs1+imm][15:0])
LWU           110      rd = zext(mem[rs1+imm][31:0])

4.4 S-Type (Store) - opcode: 0100011
------------------------------------------------------------------------------
Instruction   funct3   Operation
-----------   ------   -----------------------------------------
SB            000      mem[rs1+imm][7:0] = rs2[7:0]
SH            001      mem[rs1+imm][15:0] = rs2[15:0]
SW            010      mem[rs1+imm][31:0] = rs2[31:0]
SD            011      mem[rs1+imm][63:0] = rs2[63:0]

4.5 B-Type (Branch) - opcode: 1100011
------------------------------------------------------------------------------
Instruction   funct3   Operation
-----------   ------   -----------------------------------------
BEQ           000      if (rs1 == rs2) PC = PC + sext(imm)
BNE           001      if (rs1 != rs2) PC = PC + sext(imm)
BLT           100      if ((signed)rs1 < (signed)rs2) PC = PC + sext(imm)
BGE           101      if ((signed)rs1 >= (signed)rs2) PC = PC + sext(imm)
BLTU          110      if (rs1 < rs2) PC = PC + sext(imm)
BGEU          111      if (rs1 >= rs2) PC = PC + sext(imm)

4.6 U-Type (Upper Immediate)
------------------------------------------------------------------------------
Instruction   opcode    Operation
-----------   -------   -----------------------------------------
LUI           0110111   rd = sext(imm[31:12] << 12)
AUIPC         0010111   rd = PC + sext(imm[31:12] << 12)

4.7 J-Type (Jump)
------------------------------------------------------------------------------
Instruction   opcode    Operation
-----------   -------   -----------------------------------------
JAL           1101111   rd = PC + 4; PC = PC + sext(imm)
JALR          1100111   rd = PC + 4; PC = (rs1 + sext(imm)) & ~1

================================================================================
5. ZBA EXTENSION INSTRUCTIONS
================================================================================

Opcode: 0110011 (R-type format) and 0111011 (R-type W format)
         0011011 (I-type for SLLI.UW)

Instruction   funct7    funct3   Operation                          Use Case
-----------   -------   ------   --------------------------------   ------------------
ADD.UW        0000100   000      rd = rs2 + zext(rs1[31:0])         32-bit index add
SH1ADD        0010000   010      rd = rs2 + (rs1 << 1)              16-bit array index
SH2ADD        0010000   100      rd = rs2 + (rs1 << 2)              32-bit array index
SH3ADD        0010000   110      rd = rs2 + (rs1 << 3)              64-bit array index
SH1ADD.UW     0010000   010      rd = rs2 + (zext(rs1[31:0]) << 1)  16-bit arr, 32-bit idx
SH2ADD.UW     0010000   100      rd = rs2 + (zext(rs1[31:0]) << 2)  32-bit arr, 32-bit idx
SH3ADD.UW     0010000   110      rd = rs2 + (zext(rs1[31:0]) << 3)  64-bit arr, 32-bit idx
SLLI.UW       000010    001      rd = zext(rs1[31:0]) << shamt      Zero-extend & shift

Encoding Details:
- ADD.UW:    opcode=0111011, funct7=0000100, funct3=000
- SH1ADD:    opcode=0110011, funct7=0010000, funct3=010
- SH2ADD:    opcode=0110011, funct7=0010000, funct3=100
- SH3ADD:    opcode=0110011, funct7=0010000, funct3=110
- SH1ADD.UW: opcode=0111011, funct7=0010000, funct3=010
- SH2ADD.UW: opcode=0111011, funct7=0010000, funct3=100
- SH3ADD.UW: opcode=0111011, funct7=0010000, funct3=110
- SLLI.UW:   opcode=0011011, funct6=000010,  funct3=001

================================================================================
6. HAZARD HANDLING (STALL-ONLY)
================================================================================

6.1 Data Hazards (RAW - Read After Write)
------------------------------------------------------------------------------
Detection: Compare destination register of instruction in EX, MEM, WB stages
           with source registers (rs1, rs2) of instruction in ID stage.

Conditions for stall:
  - EX stage has valid write to rd AND (rd == rs1_id OR rd == rs2_id) AND rd != 0
  - MEM stage has valid write to rd AND (rd == rs1_id OR rd == rs2_id) AND rd != 0
  - WB stage has valid write to rd AND (rd == rs1_id OR rd == rs2_id) AND rd != 0

Stall Actions:
  - Hold PC (don't increment)
  - Hold IF/ID register (same instruction)
  - Insert NOP (bubble) into ID/EX register

6.2 Load-Use Hazard (Special case)
------------------------------------------------------------------------------
Detection: Instruction in EX is a LOAD AND its rd matches rs1 or rs2 in ID

Action: Stall for 1 cycle (same as above)

6.3 Control Hazards (Branches and Jumps)
------------------------------------------------------------------------------
Branch Resolution: Evaluated in EX stage

On Branch Taken or Jump:
  - Flush IF/ID register (insert NOP)
  - Flush ID/EX register (insert NOP)
  - Load branch target into PC

Penalty: 2 cycles for taken branches/jumps

================================================================================
7. INTERFACES
================================================================================

7.1 Top-Level Processor Interface
------------------------------------------------------------------------------
module processor_top (
    input  logic        clk,
    input  logic        rst_n,          // Active-low async reset

    // Instruction Memory Interface (read-only)
    output logic [63:0] imem_addr,      // PC value
    input  logic [31:0] imem_rdata,     // Instruction

    // Data Memory Interface (read/write)
    output logic [63:0] dmem_addr,      // Address
    output logic [63:0] dmem_wdata,     // Write data
    output logic [7:0]  dmem_byte_en,   // Byte enables
    output logic        dmem_wen,       // Write enable
    input  logic [63:0] dmem_rdata      // Read data
);

7.2 Memory Byte Enable Encoding
------------------------------------------------------------------------------
Operation   dmem_byte_en
---------   ------------
SB          8'b00000001 << addr[2:0]
SH          8'b00000011 << addr[2:0]
SW          8'b00001111 << addr[2:0]
SD          8'b11111111

================================================================================
8. MODULE HIERARCHY
================================================================================

processor_top
├── if_stage
│   └── (PC register, next PC mux)
├── if_id_reg (pipeline register)
├── id_stage
│   ├── decoder
│   ├── immediate_gen
│   └── register_file
├── hazard_unit
├── id_ex_reg (pipeline register)
├── ex_stage
│   ├── alu
│   └── branch_comparator
├── ex_mem_reg (pipeline register)
├── mem_stage
│   └── (load data alignment, store data alignment)
├── mem_wb_reg (pipeline register)
└── wb_stage
    └── (writeback mux)

================================================================================
9. FILE STRUCTURE
================================================================================

RISC-V_64I-Zba_Processor/
├── README.md                       # Project documentation
├── doc/
│   └── specification.txt           # This file
├── rtl/
│   ├── riscv_pkg.sv               # Package: opcodes, types, constants
│   ├── processor_top.sv           # Top-level processor
│   ├── if_stage.sv                # Instruction fetch stage
│   ├── id_stage.sv                # Instruction decode stage
│   ├── ex_stage.sv                # Execute stage
│   ├── mem_stage.sv               # Memory access stage
│   ├── wb_stage.sv                # Writeback stage
│   ├── register_file.sv           # 32x64-bit register file
│   ├── alu.sv                     # ALU with Zba support
│   ├── decoder.sv                 # Instruction decoder
│   ├── immediate_gen.sv           # Immediate value generator
│   ├── hazard_unit.sv             # Hazard detection (stall logic)
│   └── pipeline_regs.sv           # All pipeline registers
├── tb/
│   ├── tb_processor.sv            # Main testbench
│   ├── imem.sv                    # Instruction memory model
│   └── dmem.sv                    # Data memory model
├── sw/
│   ├── test.c                     # Test program in C
│   ├── startup.s                  # Startup assembly code
│   ├── linker.ld                  # Linker script
│   └── build_commands.txt         # RISC-V toolchain commands
└── sim/
    └── Makefile                   # Simulation Makefile (Verilator + Icarus)

================================================================================
10. CONTROL SIGNALS
================================================================================

Signal          Width   Description
--------------  -----   --------------------------------------------------------
alu_op          4       ALU operation select
alu_src_a       2       ALU source A select (rs1, PC, 0)
alu_src_b       2       ALU source B select (rs2, imm, 4)
mem_read        1       Memory read enable
mem_write       1       Memory write enable
mem_to_reg      1       Writeback source (0=ALU, 1=memory)
reg_write       1       Register file write enable
branch          1       Branch instruction flag
jump            1       Jump instruction flag (JAL/JALR)
is_jalr         1       JALR instruction (target from rs1)
mem_size        3       Memory access size (byte/half/word/double)
mem_unsigned    1       Unsigned load flag

================================================================================
11. REGISTER FILE
================================================================================

- 32 registers, each 64-bit wide
- x0 hardwired to zero (reads always return 0, writes ignored)
- 2 read ports (rs1, rs2) - combinational read
- 1 write port (rd) - synchronous write on rising edge
- Write occurs in first half of cycle, read in second half (optional)

================================================================================
12. ALU OPERATIONS
================================================================================

alu_op    Operation           Description
------    -----------------   --------------------------------
0000      ADD                 Addition
0001      SUB                 Subtraction
0010      SLL                 Shift left logical
0011      SLT                 Set less than (signed)
0100      SLTU                Set less than (unsigned)
0101      XOR                 Bitwise XOR
0110      SRL                 Shift right logical
0111      SRA                 Shift right arithmetic
1000      OR                  Bitwise OR
1001      AND                 Bitwise AND
1010      SH1ADD              Shift left 1 and add (Zba)
1011      SH2ADD              Shift left 2 and add (Zba)
1100      SH3ADD              Shift left 3 and add (Zba)
1101      ADD_UW              Add unsigned word (Zba)
1110      SLLI_UW             Shift left logical unsigned word (Zba)
1111      PASS_B              Pass operand B (for LUI)

================================================================================
13. TESTBENCH REQUIREMENTS
================================================================================

- Clock generation: 10ns period (100MHz)
- Reset: Assert for 5 cycles, then deassert
- Instruction memory: Initialize from hex file
- Data memory: Initialize to zero, monitor accesses
- Termination: ECALL instruction or timeout (10000 cycles)
- Self-checking: Assertions for expected results
- Waveform dump: VCD file for debugging

================================================================================
14. TEST PROGRAM REQUIREMENTS
================================================================================

Must demonstrate:
1. Basic arithmetic operations (ADD, SUB, AND, OR, XOR, shifts)
2. Memory access (LD, SD, LW, SW, LH, SH, LB, SB)
3. Branching logic (BEQ, BNE, BLT, BGE, loops)
4. At least 3 different Zba instructions:
   - SH1ADD (16-bit array indexing)
   - SH2ADD (32-bit array indexing)
   - SH3ADD (64-bit array indexing)

================================================================================
15. TOOLCHAIN COMMANDS (for reference)
================================================================================

Toolchain: riscv64-unknown-elf-gcc (user needs to install)

# Compile C to assembly
riscv64-unknown-elf-gcc -S -O2 -march=rv64i_zba -mabi=lp64 test.c -o test.s

# Assemble to object file
riscv64-unknown-elf-as -march=rv64i_zba test.s -o test.o

# Link to ELF
riscv64-unknown-elf-ld -T linker.ld test.o startup.o -o test.elf

# Extract machine code (hex format for simulation)
riscv64-unknown-elf-objcopy -O verilog test.elf test.hex

# Disassemble for verification
riscv64-unknown-elf-objdump -d test.elf > test.disasm

================================================================================
16. SIMULATION COMMANDS
================================================================================

Verilator (preferred):
  verilator --cc --exe --build -Wall tb_processor.sv processor_top.sv ...
  ./obj_dir/Vtb_processor

Icarus Verilog (fallback):
  iverilog -g2012 -o sim.vvp tb_processor.sv processor_top.sv ...
  vvp sim.vvp

================================================================================
END OF SPECIFICATION
================================================================================
